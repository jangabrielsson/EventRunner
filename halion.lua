return {
  EventType = {
    type = "lib",
    description = "Types of events",
    childs = {
      noteOn = {type = "value"},
      noteOff = {type = "value"},
      controller = {type = "value"},
      noteExpression = {type = "value"},
      programChange = {type = "value"},
    },
  },
  NoteExpressionType = {
    type = "lib",
    description = "Note expression types",
    childs = {
      volume = {type = "value"},
      pan = {type = "value"},
      tuning = {type = "value"},
      custom1 = {type = "value"},
      custom2 = {type = "value"},
      custom3 = {type = "value"},
      custom4 = {type = "value"},
      custom5 = {type = "value"},
      custom6 = {type = "value"},
      custom7 = {type = "value"},
      custom8 = {type = "value"},
    },
  },
  QCAssignmentMode = {
    type = "lib",
    description = "QC assignment modes",
    childs = {
      absolute = {type = "value"},
      relative = {type = "value"},
      switch = {type = "value"},
      switchRelative = {type = "value"},
    },
  },
  ModulationSource = {
    type = "lib",
    childs = {
      unassigned = {type = "value"},
      lfo1 = {type = "value"},
      lfo2 = {type = "value"},
      ampEnv = {type = "value"},
      filterEnv = {type = "value"},
      pitchEnv = {type = "value"},
      userEnv = {type = "value"},
      stepMod = {type = "value"},
      glide = {type = "value"},
      keyFollow = {type = "value"},
      noteOnVelocity = {type = "value"},
      noteOnVelocitySquared = {type = "value"},
      noteOnVelocityNormalized = {type = "value"},
      noteOffVelocity = {type = "value"},
      pitchBend = {type = "value"},
      modWheel = {type = "value"},
      aftertouch = {type = "value"},
      midiControl = {type = "value"},
      quickControl = {type = "value"},
      modulationModule = {type = "value"},
      noteExpression = {type = "value"},
      noise = {type = "value"},
      output = {type = "value"},
      bus1 = {type = "value"},
      bus2 = {type = "value"},
      bus3 = {type = "value"},
      bus4 = {type = "value"},
      bus5 = {type = "value"},
      bus6 = {type = "value"},
      bus7 = {type = "value"},
      bus8 = {type = "value"},
      bus9 = {type = "value"},
      bus10 = {type = "value"},
      bus11 = {type = "value"},
      bus12 = {type = "value"},
      bus13 = {type = "value"},
      bus14 = {type = "value"},
      bus15 = {type = "value"},
      bus16 = {type = "value"},
      sampleAndHold = {type = "value"}, 
    },
  },
  ModulationDestination = {
    type = "lib",
    childs = {
      unassigned = {type = "value"},
      pitch = {type = "value"},
      cutoff = {type = "value"},
      resonance = {type = "value"},
      distortion = {type = "value"},
      morphX = {type = "value"},
      morphY = {type = "value"},
      cutoffOffset = {type = "value"},
      resonanceOffset = {type = "value"},
      level = {type = "value"},
      volume1 = {type = "value"},
      volume2 = {type = "value"},
      pan = {type = "value"},
      sampleStart = {type = "value"},
      speedFactor = {type = "value"},
      formantShift = {type = "value"},
      grainPosition = {type = "value"},
      grainDirection = {type = "value"},
      grainDuration = {type = "value"},
      grainLength = {type = "value"},
      grainPitch = {type = "value"},
      grainFormant = {type = "value"},
      grainLevel = {type = "value"},
      osc1Pitch = {type = "value"},
      osc1Level = {type = "value"},
      osc1Waveform = {type = "value"},
      osc1MultiDetune = {type = "value"},
      osc1MultiPan = {type = "value"},
      osc1MultiVoices = {type = "value"},
      osc2Pitch = {type = "value"},
      osc2Level = {type = "value"},
      osc2Waveform = {type = "value"},
      osc2MultiDetune = {type = "value"},
      osc2MultiPan = {type = "value"},
      osc2MultiVoices = {type = "value"},
      osc3Pitch = {type = "value"},
      osc3Level = {type = "value"},
      osc3Waveform = {type = "value"},
      osc3MultiDetune = {type = "value"},
      osc3MultiPan = {type = "value"},
      osc3MultiVoices = {type = "value"},
      subOscLevel = {type = "value"},
      ringModLevel = {type = "value"},
      lfo1Freq = {type = "value"},
      lfo1Shape = {type = "value"},
      lfo2Freq = {type = "value"},
      lfo2Shape = {type = "value"},
      ampEnvAttack = {type = "value"},
      ampEnvDecay = {type = "value"},
      ampEnvSustain = {type = "value"},
      ampEnvRelease = {type = "value"},
      filterEnvAttack = {type = "value"},
      filterEnvDecay = {type = "value"},
      filterEnvSustain = {type = "value"},
      filterEnvRelease = {type = "value"},
      pitchEnvStartLev = {type = "value"},
      pitchEnvAttack = {type = "value"},
      pitchEnvAttLev = {type = "value"},
      pitchEnvDecay = {type = "value"},
      pitchEnvSustain = {type = "value"},
      pitchEnvRelease = {type = "value"},
      pitchEnvRelLev = {type = "value"},
      userEnvStartLev = {type = "value"},
      userEnvAttack = {type = "value"},
      userEnvAttLev = {type = "value"},
      userEnvDecay = {type = "value"},
      userEnvSustain = {type = "value"},
      userEnvRelease = {type = "value"},
      userEnvRelLev = {type = "value"},
      stepModFreq = {type = "value"},
      stepModSlope = {type = "value"},
      bus1 = {type = "value"},
      bus2 = {type = "value"},
      bus3 = {type = "value"},
      bus4 = {type = "value"},
      bus5 = {type = "value"},
      bus6 = {type = "value"},
      bus7 = {type = "value"},
      bus8 = {type = "value"},
      bus9 = {type = "value"},
      bus10 = {type = "value"},
      bus11 = {type = "value"},
      bus12 = {type = "value"},
      bus13 = {type = "value"},
      bus14 = {type = "value"},
      bus15 = {type = "value"},
      bus16 = {type = "value"},
      audioIn = {type = "value"},
      wavetable1Pitch = {type = "value"},
      wavetable1Level = {type = "value"},
      wavetable1Pan = {type = "value"},
      wavetable1MultiDetune = {type = "value"},
      wavetable1MultiPan = {type = "value"},
      wavetable1MultiSpread = {type = "value"},
      wavetable1MultiVoices = {type = "value"},
      wavetable1Pos = {type = "value"},
      wavetable1Dir = {type = "value"},
      wavetable1Speed = {type = "value"},
      wavetable2Pitch = {type = "value"},
      wavetable2Level = {type = "value"},
      wavetable2Pan = {type = "value"},
      wavetable2MultiDetune = {type = "value"},
      wavetable2MultiPan = {type = "value"},
      wavetable2MultiSpread = {type = "value"},
      wavetable2MultiVoices = {type = "value"},
      wavetable2Pos = {type = "value"},
      wavetable2Dir = {type = "value"},
      wavetable2Speed = {type = "value"},
      wavetableSubPitch = {type = "value"},
      wavetableSubLevel = {type = "value"},
      wavetableSubPan = {type = "value"},
      wavetableNoiseSpeed = {type = "value"},
      wavetableNoiseLevel = {type = "value"},
      wavetableNoisePan = {type = "value"},
      wavetable1FormantShift = {type = "value"},
      wavetable2FormantShift = {type = "value"},
    },
  },

  --helper keywords
  parent = {
    type = "value"
  },
  program = {
    type = "value"
  },
  instance = {
    type = "value"
  },
    
  
  -- functions
  addLayerPassword = {
    type = "function",
    description = "Function that gives access to protected layers.",
    args = "(password: string)",
    returns = "()",
  },
  addQCAssignment = {
    type = "function",
    description = "Function to add a quick control assignment to the specified layer and quick control.",
    args = "(qc: number, element: object, nameOrId: string or number, scope: element object)",
    returns = "()",
  },
  afterTouch = {
    type = "function",
    description = "Function to generate channel aftertouch events.",
    args = "(value: number 0 to 127)",
    returns = "()",
   },
  appendBus = {
    type = "function",
    description = "Function to add a bus in the specified destination layer.",
    args = "(bus: object)",
    returns = "()",
  },
  appendEffect = {
    type = "function",
    description = "Function to add an effect to the specified destination bus. ",
    args = "(effect: object)",
    returns = "()",
  },
  appendLayer = {
    type = "function",
    description = "Function to add a layer in the specified destination layer.",
    args = "(layer: object)",
    returns = "()",
  },
  appendLayerAsync = {
    type = "function",
    description = "Function to add a layer in the specified destination layer using a separate, parallel thread. ",
    args = "(layer: object [,callback: callback function that is called when layer is added])",
    returns = "(LoadProgress: object)",
  },
  appendMidiModule = {
    type = "function",
    description = "Function to add a MIDI module in the specified destination layer.",
    args = "(module: object)",
    returns = "()",
  },
  appendZone = {
    type = "function",
    description = "Function to add a zone in the specified destination layer.",
    args = "(zone: object)",
    returns = "()",
  },
  assignAutomation = {
    type = "function",
    description = "Function to assign a parameter to an automation parameter.",
    args ="(element: object, parameter nameOrId: string or number [, index: number or nil])",
    returns = "()",
  },
  AudioFile = {
    type = "class",
    childs = {
      open ={
        type = "function",
        description = "The AudioFile.open function creates an AudioFile object of the specified audio file. The AudioFile object has the following fields:\n.valid (boolean)\n.fileName (string)\n.rate (number)\n.bits (number)\n.channels (number)\n.length (number)\n.rootKey (number)\n.keyLow (number)\n.keyHigh (number)\n.velLow (number)\n.velHigh (number)\n.detune (number)\n.level (number)\n.tempo (number)\n.beats (number)\n.signature (number, number)\n.sampleStart (number)\n.sampleEnd (number)\n.loops (table with fields loopStart and loopEnd)",
        args = "(filename: string)",
        returns = "(AudioFile: object)",
      },
    },
  },
  beat2ms = {
    type = "function",
    description = "Function to convert a number of beats to the equivalent duration in milliseconds.",
    args = "(beats: number)",
    returns = "(number)",
  },
  calcModulation = {
    type = "function",
    description = "Function to generate the modulation signals that have been defined with defineModulation. Multiple modulation signals can be returned as a tuple or as a table. If the modulation is defined as unipolar, the signal must be in the range from 0.0 to 1.0. If the modulation is defined as bipolar, the signal must be in the range from -1.0 to 1.0.",
    args = "",
    returns = "(Returns one or more modulation signals.)",
  },
  changeNoteExpression = {
    type = "function",
    description = "Function to change the note expression of a specific note.",
    args = "(noteId: number, type: enum or number, value: number [, relative: boolean [, immediateOrDuration: boolean or number]])",
    returns = "()",
  },
  changePan ={
    type = "function",
    description ="Function to change the position of a specific note in the panorama.",
    args = "(noteId: number, pan: number -1.0 to 1.0 [, relative: boolean [, immediateOrDuration: boolean or number]])",
    returns = "()",
  },
  changeTune = {
    type = "function",
    description = "Function to change the tuning of a specific note in semitones.",
    args = "(noteId: number, tune: number -120.0 to 120.0 [,relative: boolean [, immediateOrDuration: boolean or number]])",
    returns = "()",
  },
  changeVolume = {
    type = "function",
    description = "Function to change the volume of a specific note. A gain factor greater than 1.0 amplifies the signal and a gain factor smaller than 1.0 attenuates the signal.",
    args = "(noteId: number, gain: number [, relative: boolean [, immediateOrDuration: boolean or number]])",
    returns = "()",
  },
  changeVolumedB = {
    type = "function",
    description = "Function to change the volume of a specific note in decibels (dB). Positive values amplify the signal and negative values attenuate the signal.",
    args = "(noteId: number, gain_dB: number [, relative: boolean [, immediateOrDuration: boolean or number]])",
    returns = "()",
  },
  clone = {
    type = "function",
    description = "Function to create a copy of the specified event.",
    args = "(event: object)",
    returns = "(Returns a copy of the specified event.)",
  },
  controlChange = {
    type = "function",
    description = "Function to generate controller events.",
    args = "(controller: number, value: number)",
    returns = "()",
  },
  defineModulation = {
    type = "function",
    description = "Function to declare a modulation output for the script module, which can be assigned in the modulation matrix of the zone.",
    args = "(name: string, bipolar: boolean)",
    returns = "()",
  },
  defineParameter = {
    type = "function",
    description = "Function to specify a parameter with the specified name and characteristics.",
    args = "()",
    returns = "()",
  },
  defineSlotLocal = {
    type = "function",
    description = "Function to attain global variables that operate independently per slot.",
    args = "(name: string)",
    returns = "()",
  },
  endUndoBlock = {
    type = "function",
    description = "Function to terminate an undo block. An undo block begins with startUndoBlock.",
    args = "()",
    returns = "()",
  },
  Event = {
    type = "function",
    description = "Constructor to create a new Event object of the specified type. The fields of the Event object must be set after its creation.",
    args = "(type: EventType)",
    returns = "(Event: object)",
  },
  fade = {
    type = "function",
    description = "Function to fade the volume of a specific note. The fade is performed from the start to the target value with the specified duration in milliseconds and affects all voices that are triggered by the note.",
    args = "(noteId: number, startValue: number 0-1.0|nil, targetValue: number 0-1.0, duration in ms: number, killVoice: boolean)",
    returns = "()",
  },
  findBusses = {
    type = "function",
    description = "Function to find busses in the specified Element object.",
    args = "([recursive: boolean [, nameOrFilterFunction: string or function]])",
    returns = "(bus objects: array)",
  },
  findChildren = {
    type = "function",
    description = "Function to find children in the specified Element object.",
    args = "([recursive: boolean [,nameOrFilterFunction: string or function]])",
    returns = "(element objects: array)",
  },
  findEffects = {
    type = "function",
    description = "Function to find effects in the specified Element object.",
    args = "([recursive: boolean [, nameOrFilterFunction: string or function]])",
    returns = "(effect objects: array)",
  },
  findLayers = {
    type = "function",
    description = "Function to find layers in the specified layer.",
    args = "([recursive: boolean [, nameOrFilterFunction: string or function]])",
    returns = "(layer objects: array)",
  },
  findMidiModules = {
    type = "function",
    description = "Function to find MIDI modules in the specified layer.",
    args = "([recursive: boolean [, nameOrFilterFunction: string or function]])",
    returns = "(midiModule objects: array)",
  },
  findSlots = {
    type = "function",
    description = "Function to find the slots of the plug-in instance. Before calling this function you must access the Instance object with this.program.instance.",
    args = "([nameOrFilterFunction: string or function)",
    returns = "(slot objects: array)",
  },
  findZones = {
    type = "function",
    description = "Function to find zones in the specified layer.",
    args = "([recursive: boolean [, nameOrFilterFunction: string or function]])",
    returns = "(zone objects: array)",
  },
  forgetAutomation = {
    type = "function",
    description = "Function to remove the specified parameter from its automation parameter.",
    args = "(element: element, nameOrId: number)",
    returns = "()",
  },
  getAllocatedMemory = {
    type = "function",
    description = "Function to obtain the number of bytes which have been allocated to the script in the memory.",
    args = "()",
    returns = "(number)",
  },
  getAutomationIndex = {
    type = "function",
    description = "Function to retrieve the index of the automation parameter to which the specified parameter is assigned. Returns the the index of the automation parameter to which the specified parameter is assigned, or nil if the specified parameter is not assigned.",
    args = "(element: element, nameOrId: number)",
    returns = "(number|nil)",
  },
  getBarDuration = {
    type = "function",
    description = "Function to obtain the duration of one bar in milliseconds. If no time signature or tempo are available, this function returns the value -1.",
    args = "()",
    returns = "(number)",
  },
  getBeatDuration = {
    type = "function",
    description = "Function to obtain the duration of one beat in milliseconds. If no tempo information is available, this function returns the value -1.",
    args = "()",
    returns = "(number)",
  },
  getBeatTime = {
    type = "function",
    description = "Function to obtain the current song position in number of beats. The start of the song equals 0 beats. The function returns -1 if the host is not in playback.",
    args = "()",
    returns = "(number)",
  },
  getBeatTimeInBar = {
    type = "function",
    description = "Function to obtain the position in the current bar in number of beats. The start of the bar equals 0 beats. The function returns -1 if the host is not in playback.",
    args = "()",
    returns = "(number)",
  },
  getBus = {
    type = "function",
    description = "Function to retrieve the Bus object of a bus in the specified Element object.",
    args = "([nameOrPosition: string|number])",
    returns = "(bus object)",
  },
  getCC = {
    type = "function",
    description = "Function to read the current value of a continuous controller.",
    args = "(controller: number)",
    returns = "(number)",
  },
  getChild = {
    type = "function",
    description = "Function to retrieve the Element object of a child in the specified Element object.",
    args = "([nameOrPosition: string|number])",
    returns = "(element object)",
  },
  getContext = {
    type = "function",
    description = "Function to obtain the name of the context.",
    args = "()",
    returns = "(string)",
  },
  getDisplayString = {
    type = "function",
    description = "Function to obtain the display string of the specified parameter and value. Specify the parameter with getParameterDefinition.",
    args = "(value: number|string)",
    returns = "(display string: string)",
  },
  getEffect = {
    type = "function",
    description = "Function to retrieve the Effect object of an effect from the specified bus.",
    args = "([nameOrPosition: string|number])",
    returns = "(effet object)",
  },
  getElement = {
    type = "function",
    description = "Function to obtain the Element object of an element that has a macro page. This function can only be called in an UI script.",
    args = "()",
    returns = "(element object)",
  },
  getFreeVoices = {
    type = "function",
    description = "Function to retrieve the number of free voices of the plug-in instance.",
    args = "()",
    returns = "(number)",
  },
  getHostName = {
    type = "function",
    description = "Function to retrieve the name of the host software.",
    args = "()",
    returns = "(string)",
  },
  getHostVersion = {
    type = "function",
    description = "Function to retrieve the version of the host software.",
    args = "()",
    returns = "(string)",
  },
  getKeyProperties = {
    type = "function",
    description = "Function to access the internal key properties array. This array manages the colors and tooltips of the keys on the plug-in keyboard and the instrument names that will be shown in Cubase's Drum Editor when you use Create Drum Map from Instrument in the Inspector. Fields of the array returned by this function are:\n.color\n.tooltip\n.drummap",
    args = "()",
    returns = "(key properties: array)",
  },
  getKeySwitches = {
    type = "function",
    description = "Function to access the internal key switch array. This array manages the display of the key switches on the plug-in keyboard and the information that is handed over to Cubase's Expression Map when you use Import Key Switches in the Inspector. Fields of the array returned by this function are:\n.name (string)\n.keyMin (number)\n.keyMax (number, optional (defaults to keyMin if not set))\n.keyRemapped (number, optional)",
    args = "()",
    returns = "(key switches: array)",
  },
  getLayer = {
    type = "function",
    description = "Function to retrieve the Layer object of a layer in the specified layer.",
    args = "([nameOrPosition: string|number])",
    returns = "(layer object)",
  },
  getMidiModule = {
    type = "function",
    description = "Function to retrieve the MidiModule object of a MIDI module in the specified layer.",
    args = "([nameOrPosition: string|number])",
    returns = "(midiModule object)",
  },
  getModulationMatrixRow = {
    type = "function",
    description = "Function to obtain the ModulationMatrixRow object of the specified modulation matrix row. The modulation matrix row is determined by the Zone object of the zone and the index of the modulation matrix row.",
    args = "(rowNumber: number)",
    returns = "(modulationMatrixRow object)",
  },
  getMsTime = {
    type = "function",
    description = "Function to obtain the current song position in milliseconds. The function returns -1 if the host is not in playback.",
    args = "()",
    returns = "(number)",
  },
  getNoteDuration = {
    type = "function",
    description = "Function to measure the time delta between the last note-on event of the specified note and the call of this function. Returns the time delta in milliseconds.",
    args = "(noteNumber in range of 0 to 127: number)",
    returns = "(number)",
  },
  getNoteExpression = {
    type = "function",
    description = "Function to read the current value of a note expression of a specific note. Returns the current value of the note expression determined by the arguments. The function returns -1 if the value of the note expression has not been set yet.",
    args = "(noteID: number, type: enum or number)",
    returns = "(number)",
  },
  getNoteExpressionProperties = {
    type = "function",
    description = "Function to access the internal array that manages the appearance of the custom note expressions. In HALion, these are found in the Note Expression section and in Cubase, in the Note Expression section of the Inspector. For example, if your script generates note expression events, you can give the associated custom note expressions meaningful names or you can hide them. The first time you call getNoteExpressionProperties, the returned array will be empty. You change the properites by assigning a table with the fields: \n.name\n.block \nto the index of the array that corresponds to the custom note expression. The indices from 4 to 11 correspond to the custom note expressions 1 to 8 (see Note Expression Types for details). The properties defined by this script will override any properties that come later in the processing chain.",
    args = "()",
    returns = "(note expression properties: array)",
  },
  getNumQCAssignments = {
    type = "function",
    description = "Function to retrieve the number of assignments of a quick control on the specified layer.",
    args = "(qc: number)",
    returns = "(number)",
  },
  getOutputBus = {
    type = "function",
    description = "Function to retrieve the currently assigned output bus of a zone or bus. Returns the Bus object of the currently assigned output bus or nil if the default routing is used.",
    args = "()",
    returns = "(object|nil)",
  },
  getParameter = {
    type = "function",
    description = "Function to read the current value of a parameter. Returns the current value of the parameter or nil if the parameter doesn't exist.",
    args = "(nameOrID: string|number)",
    returns = "(value|nil)",
  },
  getParameterDefinition = {
    type = "function",
    description = "Function to retrieve the ParameterDefinition object for a parameter.",
    args = "(nameOrID: string|number)",
    returns = "(parameterDefinition object)",
  },
  getParameterNormalized = {
    type = "function",
    description = "Function to read the current value of a parameter in the normalized range from 0 to 1.0. The parameter can be determined by name or ID.Returns the current value of the parameter in the normalized range from 0 to 1.0 or nil if the parameter doesn't exist. If the parameter is not numeric, the function returns the same as getParameter",
    args = "(nameOrID: string|number)",
    returns = "(number|nil)",
  },
  getPeak = {
    type = "function",
    description = "Function to analyze the levels in an audio file. You specify the audio file with the AudioFile object that is returned by the AudioFile.open function. The arguments start and length define the range in the audio file to be analyzed. The rms argument determines whether the peak level or the RMS level of the specified range is returned. Returns the level of the specifed range as a linear value.",
    args = "(start: number, length: number, rms: number)",
    returns = "(number)",
  },
  getProductName = {
    type = "function",
    description = "Function to retrieve the name of the plug-in.",
    args = "()",
    returns = "(string)",
  },
  getProductVersion = {
    type = "function",
    description = "Function to retrieve the version of the plug-in.",
    args = "()",
    returns = "(string)",
  },
  getProgram = {
    type = "function",
    description = "Function to retrieve the Program object of a program in the Program Table of the plug-in instance. Before calling this function you must access the Instance object with this.program.instance. Returns the Program object of the program with the specified index.",
    args = "(index: number)",
    returns = "(program object)",
  },
  getQCAssignmentBypass = {
    type = "function",
    description = "Function to retrieve the bypass state of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself.",
    args = "(qc: number, assignment: number)",
    returns = "(boolean)",
  },
  getQCAssignmentCurve = {
    type = "function",
    description = "Function to retrieve the curve value of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. The value range is -100 % to +100 %.",
    args = "(qc: number, assignment: number)",
    returns = "(number)",
  },
  getQCAssignmentMax = {
    type = "function",
    description = "Function to retrieve the maximum value of the specified quick control assignment. The quick control assignment is determined by the Layer, the index of the quick control and the index of the assignment itself. The value range is always 0 to 100 %, even if the mode of the quick control assignment is set to Relative or Switch Relative.",
    args = "(qc: number, assignment: number)",
    returns = "(number)",
  },
  getQCAssignmentMin = {
    type = "function",
    description = "Function to retrieve the minimum value of the specified quick control assignment. The quick control assignment is determined by the Layer, the index of the quick control and the index of the assignment itself. The value range is always 0 to 100 %, even if the mode of the quick control assignment is set to Relative or Switch Relative.",
    args = "(qc: number, assignment: number)",
    returns = "(number)",
  },
  getQCAssignmentMode = {
    type = "function",
    description = "Function to retrieve the mode that is set for the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. Returns the mode that is set for the specified quick control assignment as a number. The mode can be determined via names or indices.",
    args = "(qc: number, assignment: number)",
    returns = "(number|name)",
  },
  getQCAssignmentParamId = {
    type = "function",
    description = "Function to retrieve the parameter ID of the parameter that is connected to the specified quick control assignment. The quick control assignment is determined by the Layer, the index of the quick control and the index of the assignment itself. Returns the parameter ID of the parameter connected to the specified quick control assignment.",
    args = "(qc: number, assignment: number)",
    returns = "(number)",
  },
  getQCAssignmentScope = {
    type = "function",
    description = "Function to retrieve the element object that is set as scope for the specified quick control assignment. The quick control assignment is determined by the Layer object of the layer, the index of the quick control and the index of the assignment itself. Returns the element object that is set as scope for the specified quick control assignment.",
    args = "(qc: number, assignment: number)",
    returns = "(element object)",
  },
  getSamplingRate = {
    type = "function",
    description = "Function to retrieve the sample rate from the host software. Returns the sample rate of the host software in Hertz.",
    args = "()",
    returns = "(number)",
  },
  getScriptExecTimeOut = {
    type = "function",
    description = "Function to read the duration of the script execution time-out either for the controller or the processor thread, depending on where getScriptExecTimeOut is called. The duration for the script execution time-out is returned in milliseconds.",
    args = "()",
    returns = "(number)",
  },
  getScriptVersion = {
    type = "function",
    description = "Function to retrieve the version of the script engine.",
    args = "()",
    returns = "(string)",
  },
  getSlot = {
    type = "function",
    description = "Function to retrieve the Slot object of a slot of the plug-in instance. Before calling this function you must access the Instance object with this.program.instance. Returns the Slot object of the found slot. Returns nil if no slot is found.",
    args = "([nameOrIndex: string|number])",
    returns = "(slot object)",
  },
  getSlotIndex = {
    type = "function",
    description = "Function to retrieve the index of the slot in which the program is loaded.",
    args = "()",
    returns = "(index: number)",
  },
  getSource1 = {
    type = "function",
    description = "Function to retrieve the 1st modulation source of a row in the modulation matrix. The row is specified with the Zone object of the zone and the index of the modulation matrix row. \nReturns up to three values, i.e., source, sourceInfo1 and sourceInfo2.",
    args = "()",
    returns = "(...)",
  },
  getSource2 = {
    type = "function",
    description = "Function to retrieve the 2nd modulation source of a row in the modulation matrix. The row is specified with the Zone object of the zone and the index of the modulation matrix row. \nReturns up to three values, i.e., source, sourceInfo1 and sourceInfo2.",
    args = "()",
    returns = "(...)",
  },
  getTempo = {
    type = "function",
    description = "Function to read the tempo of the host software. Returns the current tempo in beats per minute (BPM). If no tempo information is available, this function returns the value -1.",
    args = "()",
    returns = "(number)",
  },
  getTime = {
    type = "function",
    description = "Function to obtain the time in milliseconds since the initialization of the script. The function starts to count from 0 ms each time that you reload or reset the script.",
    args = "()",
    returns = "(number)",
  },
  getTimeSignature = {
    type = "function",
    description = "Function to read the time signature from the host software. Returns the numerator and denominator of the time signature. If no time signature information is available, the value -1 is returned for both the numerator and the denominator.",
    args = "()",
    returns = "(number, number)",
  },
  getUsedMemory = {
    type = "function",
    description = "Function to obtain the amount of memory that is used by the script. Returns the number of bytes in the memory that are used by the script.",
    args = "()",
    returns = "(number)",
  },
  getUsedVoices = {
    type = "function",
    description = "Function to obtain the number of used voices of the plug-in instance.",
    args = "()",
    returns = "(number)",
  },
  getUsedVoicesOfSlot = {
    type = "function",
    description = "Function to obtain the number of used voices of the slot in which a program is loaded.",
    args = "()",
    returns = "(number)",
  },
  getUserPresetPath = {
    type = "function",
    description = "Function to obtain the file path for the user VST presets of a product. If no product argument is set, the function returns the file path of the current plug-in.",
    args = "([product: string])",
    returns = "(file path: string)",
  },
  getVoices = {
    type = "function",
    description = "Function to retrieve the maximum number of voices of the plug-in instance as set in the Options editor.",
    args = "()",
    returns = "(number)",
  },
  getZone = {
    type = "function",
    description = "Function to retrieve the Zone object of a zone in the specified layer. Returns the Zone object of the found zone. Returns nil if no zone is found.",
    args = "([nameOrPosition: string|number])",
    returns = "(zone object)",
  },
  hasParameter = {
    type = "function",
    description = "Function to check if a parameter exists. The parameter can be determined by name or ID. Returns true if the parameter exists or false if not.",
    args = "(nameOrID: string|number)",
    returns = "(boolean)",
  },
  insertBus = {
    type = "function",
    description = "Function to insert a bus at the specified position in the destination layer. The bus to be inserted is determined by its Bus object.",
    args = "(bus: object, position: number)",
    returns = "()",
  },
  insertEffect = {
    type = "function",
    description = "Function to insert an effect at a specific position in a destination bus. The effect to be inserted is determined by its Effect object.",
    args = "(effect: object, position: number)",
    returns = "()",
  },
  insertEnvelopePoint = {
    type = "function",
    description = "Function to insert an envelope point in the specified envelope. You specify the envelope by calling getParameter with the EnvelopePoints parameter of the desired envelope as argument. If you call getParameter with the EnvelopePoints parameter as argument, an array with the current envelope points will be returned. Each index of the array represents an envelope point with the fields: \n.level\n.duration\n.curve \nThe insertEnvelopePoint function modifies this array. To apply the changes, you must use setParameter with the EnvelopePoints parameter of the envelope as argument and the array as value.",
    args = "(envelopeArray: table, index: number, level: number, duration: number, curve: number)",
    returns = "()",
  },
  insertEvent = {
    type = "function",
    description = "Function to insert an event in the specified events table according to its PPQ position. The events table is part of a tracks table which is part of the MIDI sequence table.",
    args = "(eventsTable: table, event: object)",
    returns = "()",
  },
  insertLayer = {
    type = "function",
    description = "Function to insert a layer at a specific position in a destination layer. The layer to be inserted and the destination layer are both determined by their Layer objects.",
    args = "(layer: object, position: number)",
    returns = "()",
  },
  insertLayerAsync = {
    type = "function",
    description = "Function to insert a layer at a specified position in a destination layer using a separate, parallel thread. Inserting a layer in a separate thread can be necessary if the layer is too big to be inserted in a short time. The layer to be inserted and the destination layer are both determined by their Layer objects.\nThe function returns a LoadProgress object that can be used to monitor the load progress. After the layer is inserted, the callback function is called. The callback function gets the LoadProgress object as default argument.",
    args = "(layer: object, position: number [, callback: function])",
    returns = "(loadProgress object)",
  },
  insertMidiModule = {
    type = "function",
    description = "Function to insert a MIDI module at the specified position in the determined destination layer. The MIDI module to be inserted is determined by its MidiModule object.",
    args = "(module: object, position: number)",
    returns = "()",
  },
  insertZone = {
    type = "function",
    description = "Function to insert a zone at the specified position in the determined layer. The zone to be inserted is determined by its Zone object.",
    args = "(zone: object, position: number)",
    returns = "()",
  },
  isKeyDown = {
    type = "function",
    description = "Function to detect whether a key with a specific note number is held or not. Returns true if the key with the specified note number is held and false if the key has been released. The note events must come from outside the script, e.g., from the host software or another MIDI module.",
    args = "(note: number)",
    returns = "(boolean)",
  },
  isNoteHeld = {
    type = "function",
    description = "Function to detect inside the onNote callback function if a note is held or not. Calling this function inside other callback functions is not permitted. Returns true if onNote has received a note-on event and false if onNote has received a corresponding note-off event.",
    args = "()",
    returns = "(boolean)",
  },
  isOctaveKeyDown = {
    type = "function",
    description = "Function to detect whether a key is held or not, regardless of the octave. Returns true if the specified key is held, no matter in which octave. The function returns false if the specified key and any octave keys have been released.",
    args = "(note: number)",
    returns = "(boolean)",
  },
  isPlaying = {
    type = "function",
    description = "Function to detect whether the host is in playback. Returns true if the host is in playback and false if not.",
    args = "()",
    returns = "(boolean)",
  },
  loadPreset = {
    type = "function",
    description = "Function to load the elements of a VST preset. Depending on whether you load a layer, program or multi-program VST preset, the function returns either an Element object of the type Layer, Program or Instance. You can use the returned Element object to insert layers, zones, MIDI modules, busses, effects, etc. from the VST preset into the program or HALion instance where the script is executed.",
    args = "(path: string)",
    returns = "(element object)",
  },
  loadPresetAsync = {
    type = "function",
    description = "Function to load the elements of a VST preset in a separate, parallel thread. Loading the VST preset in a separate thread can be necessary if the preset is too big to be loaded in a short time. The function returns a LoadProgress object that can be used to get information on the load progress and the loaded elements, for example. After the preset is loaded, the callback function is called. The callback function gets the LoadProgress object as default argument.",
    args = "(path: string [, callback: function])",
    returns = "(loadProgress object)",
  },
  messageBox = {
    type = "function",
    description = "Function to open a modal message box. If the argument is a single string, the text will be displayed in the default message box. Alternatively, you can customize the message box by using a configuration table, e.g., if you want to display the text with a warning icon. The message box can be configured by creating a table with the following fields:\n.type (enum or number)\n    1 (MessageBoxType.warning)\n    2 (MessageBoxType.question)\n    3 (MessageBoxType.information)\n.text (string)\n.button1 (string, optional)\n.button2 (string, optional)\n.button3 (string, optional)\nReturns the result of the message box, i.e., which action closed the message box, as a number:\n1 (MessageBoxResult.escape)\n2 (MessageBoxResult.button1)\n3 (MessageBoxResult.button2)\n4 (MessageBoxResult.button3)",
    args = "(stringOrConfigTable: string|table)",
    returns = "(number)",
  },
  ms2beat = {
    type = "function",
    description = "Function to convert a duration in milliseconds to the equivalent number of beats. One beat equals a quarter note. The current tempo is taken into account.",
    args = "(ms: number)",
    returns = "(number)",
  },
  ms2samples = {
    type = "function",
    description = "Function to convert a duration in milliseconds to the equivalent number of samples. The conversion takes into account the sample rate at which the plug-in runs.",
    args = "(ms: number)",
    returns = "(number)",
  },
  onAfterTouch = {
    type = "function",
    description = "This callback function is called when the script module receives a channel aftertouch event. If the script doesn't implement onAfterTouch, all aftertouch events will be passed on to onController. Event object has fields:\n.type (3= controller)\n.value (value in the range of 0 to 127, number)",
    args = "(event: object)",
    returns = "()",
  },
  onController = {
    type = "function",
    description = "This callback function is called when the script module receives a continuous controller event. If the script doesn't implement onAfterTouch or onPitchBend, the respective aftertouch or pitch bend events will be passed on to onController. This way, continuous controller, aftertouch and pitch bend events can be treated in the same callback function onController. Event object has fields:\n.type (3= controller)\n.controller (number)\n.value (value in the range of 0 to 127, number)",
    args = "(event: object)",
    returns = "()",
  },
  onInit = {
    type = "function",
    description = "This callback function is called after executing any global statements and the onLoadIntoSlot callback function. It is the first callback function that is called when the processor thread is initialized. You can use this function to initialize variables with information from the context, for example.\nThe program must be loaded in the Slot Rack and contain at least one zone. Otherwise, onInit won't be called.",
    args = "()",
    returns = "()",
  },
  onLoad = {
    type = "function",
    description = "This callback function is called when the script module is loaded as part of a preset or project. The data that is passed on is the data that was returned by onSave when the script module was saved.",
    args = "(data)",
    returns = "()",
  },
  onLoadIntoSlot = {
    type = "function",
    description = "This callback function is called when the program is loaded into the Slot Rack. Any global statements are executed in advance. onInit is called after onLoadIntoSlot.",
    args = "()",
    returns = "()",
  },
  onLoadSubPreset = {
    type = "function",
    description = "This callback function is called when loading a subpreset with a corresponding Preset Browser template. The callback will only be called if the scope of the Preset Browser template is set correctly. In adition, the Preset Browser Custom template allows you to define a section for the subpreset. When you load a subpreset, the defined section and the data stored in the subpreset will be passed on to the callback. The data is the same data that was returned by onSaveSubPreset when the subpreset was saved. You can manage different subsets of parameters by using the section as condition for an if statement that restores only the parameters of interest.\nScope and section are template parameters. You can set them in the MacroPage Designer on the properties pane of the Preset Browser and Preset Browser Custom templates.",
    args = "(section; string, data)",
    returns = "()",
  },
  onNote = {
    type = "function",
    description = "This callback function is called when the script module receives a note-on event. Event object has fields:\n.type (1=noteOn: number)\n.id (note ID: number)\n.note (note number in the range of 0 to 127, number)\n.velocity (velocity in the range of 0 to 127, number)",
    args = "(event: object)",
    returns = "()",
  },
  onNoteExpression = {
    type = "function",
    description = "This callback function is called when the script module receives a note expression event. Note expression events are always processed by the engine, regardless of whether the event is posted or not. Therefore, the use of postEvent is not necessary. Event object has fields:\n.type (4=noteExpression: number)\n.id (the ID of the associated note-on event: number)\n.noteExpressionType (type of note expression: number)\n.value (note expression value in range of 0 to 1.0, number)",
    args = "(event: object)",
    returns = "()",
  },
  onPitchBend = {
    type = "function",
    description = "This callback function is called when the script module receives a pitch bend event. The .value field of the Event object contains the pitch bend value as a signed integer in the range from -8191 to 8191. The .bend field contains the pitch bend value as a floating point number in the range from -1.0 to 1.0. Use .bend for greater accuracy. \nIf your script doesn't implement onPitchBend, all pitch bend events will be passed on to onController.",
    args = "(event: object)",
    returns = "()",
  },
  onRelease = {
    type = "function",
    description = "This callback function is called when the script module receives a note-off event. Event object has fields:\n.type (2=noteOff, number)\n.id (note ID of the note-off event, number)\n.note (note number in range of 0 to 127, number)\n.velocity (note-off velocity in the range of 0 to 127, number)",
    args = "(event: object)",
    returns = "()",
  },
  onRemoveFromSlot = {
    type = "function",
    description = "This callback function is called when the program is removed from the Slot Rack.",
    args = "()",
    returns = "()",
  },
  onSave = {
    type = "function",
    description = "This callback function is called when the script module is saved as part of a preset or project. The data you pass on to the return statement will be stored with the preset or project. The data can be of any type, but it is common practice to use a table that can easily be extended with more fields. When the script module is restored, the onLoad callback will receive the stored data.",
    args = "()",
    returns = "(data)",
  },
  onSaveSubPreset = {
    type = "function",
    description = "This callback function is called when saving a subpreset with a corresponding Preset Browser template. The callback will only be called if the scope of the Preset Browser template is set correctly. In addition, the Preset Browser Custom template allows to define a section for the subpreset. When you save a subpreset, the section will be passed on from the Preset Browser Custom template to the callback. You can manage different subsets of parameters by using the section as condition for an if statement that stores only the parameters of interest. The data you pass on to the return statement will be stored with the subpreset. The data can be of any type, but it is common practice to use a table that can easily be extended with more fields. When the subpreset is restored, the onLoadSubPreset callback will receive the stored data. Scope and section are template parameters. You can set them in the MacroPage Designer on the properties pane of the Preset Browser and Preset Browser Custom templates.",
    args = "(section: string)",
    returns = "(data)",
  },
  onTriggerPad = {
    type = "function",
    description = "This callback function is called when the script module receives a trigger event from a trigger pad. The Trigger Pads module must be placed before the script module. Trigger events are produced when the pad is pressed with the mouse, when a trigger note is played via MIDI or by calling playTriggerPad from another script module.",
    args = "(number of trigger pad: number)",
    returns = "()",
  },
  onUnhandledEvent = {
    type = "function",
    description = "This callback function is called when the script module receives an event that is not handled by the specific event callback functions, e.g., onNote, onRelease, onController and onNoteExpression. If none of the specific callback functions are defined, onUnhandledEvent will receive all incoming events.",
    args = "(event: object)",
    returns = "()",
  },
  openURL = {
    type = "function",
    description = "Function to open a  website in the web browser.",
    args = "(adress: string)",
    returns = "()",
  },
  pitchBend = {
    type = "function",
    description = "Function to generate pitch bend events. The pitch bend value in the range of -1.0 to 1.0.",
    args = "(value: number)",
    returns = "()",
  },
  playNote = {
    type = "function",
    description = "Function to generate note events. If duration is -1 the generated note plays as long as the key that called playNote is held. Arguments:\n Duration: If duration is greater than 0 the note plays as long as the key is held, but maximum for the time specified in milliseconds. If duration is 0 playNote generates only the note-on event. The release can be managed manually with onRelease or with releaseVoice and the ID returned by playNote.\nLayerOrZone: The layer or zone which shall receive the note. Only elements after the script module are addressable. The default is nil (all layers).\nVolume: The initial volume in the range of 0 to 1.0. The default is 1.0.\nPan: The initial pan position in the range of -1.0 to 1.0. The default is 0.\nTune: The initial tuning in the range of -120.0 to 120.0. The default is 0.",
    args = "(note: number, velocity: number [, duration: number [, layerOrZone: object [, volume: number [, pan: number [, tune: number]]]]])",
    returns = "(note ID)",
  },
  playTriggerPad = {
    type = "function",
    description = "Function to send the trigger events of the Trigger Pads to subsequent modules of the script module. This function does not trigger the pads of the Trigger Module. It only changes the state of the trigger pads in the depending modules, for example, to switch between the variations of a FlexPhraser or MIDI Player.",
    args = "(number of trigger pad: number)",
    returns = "()",
  },
  postEvent = {
    type = "function",
    description = "Function to post the event to the engine. The second argument is optional. It allows you to delay the event by a specific time in milliseconds. Returns a note ID in case of a note-on event, nil for any other type of event. For this reason, assigning the return value of postEvent to a variable is only meaningful in the onNote callback.",
    args = "(event: object [, delay: number])",
    returns = "(note ID|nil)",
  },
  printRaw = {
    type = "function",
    description = "Receives any number of arguments and prints their values to the output window of the script module. In contrast to Lua's print function, printRaw does not insert a space character after every value and does not add a line feed on the end.",
    args = "(value1, value2, ...)",
    returns = "()",
  },
  readMidiFile = {
    type = "function",
    description = "Function to read a MIDI file (.mid). The function creates a MIDI sequence table that contains the data of the MIDI file.",
    args = "(path: string)",
    returns = "(MIDI sequence table)",
  },
  releaseVoice = {
    type = "function",
    description = "Function to release a note with a specific note ID.",
    args = "(noteID: number)",
    returns = "()",
  },
  removeBus = {
    type = "function",
    description = "Function to remove a bus from the specified layer. The bus to be removed is determined by its Bus object or its position. The position is the number that indexes the busses in the specified layer.",
    args = "(busOrPosition: object|number)",
    returns = "()",
  },
  removeEffect = {
    type = "function",
    description = "Function to remove an effect from a bus. You can use getBus or findBusses to define the bus that contains the effect. The effect to be removed is determined by its Effect object or its position. You can use getEffect or findEffects to determine the Effect object. The position is the number indexing the effects in the bus.",
    args = "(effectOrPosition: object|number)",
    returns = "()",
  },
  removeEnvelopePoint = {
    type = "function",
    description = "Function to remove an envelope point from the specified envelope. You specify the envelope by calling getParameter with the EnvelopePoints parameter of the desired envelope as argument. If you call getParameter with the EnvelopePoints parameter as argument, an array with the current envelope points will be returned. Each index of the array represents an envelope point with the fields: \n.level \n.duration \n.curve  \nThe removeEnvelopePoint function modifies this array. To apply the changes, you must use setParameter with the EnvelopePoints parameter of the envelope as argument and the array as value.",
    args = "(envelopeArray: table, index: number)",
    returns = "()",
  },
  removeFromParent = {
    type = "function",
    description = "Function to remove an element in the Program Tree from the parent element. The function can remove elements of the type Layer, Zone, MidiModule, Bus and Effect. It can even remove the script module that calls the function.",
    args = "()",
    returns = "()",
  },
  removeLayer = {
    type = "function",
    description = "Function to remove a layer from the specified layer. The layer is determined by its Layer object or its position. You can use getLayer or findLayers to determine the Layer object. The position is the number indexing the layers within the specified layer.",
    args = "(layerOrPosition: object|number)",
    returns = "()",
  },
  removeMidiModule = {
    type = "function",
    description = "Function to remove a MIDI module from the specified layer. The MIDI module to be removed is determined by its MidiModule object or its position. You can use getMidiModule or findMidiModules to determine the MidiModule object. The position is the number that indexes the MIDI modules in the specified layer.",
    args = "(moduleOrPosition: object|number)",
    returns = "()",
  },
  removeQCAssignment = {
    type = "function",
    description = "Function to remove a quick control assignment from the specified layer and quick control. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control with the assignment to be removed. The assignment argument is the index of the quick control assignment to be removed. The indices of the quick controls and the assignments both start counting from 1.",
    args = "(qc: number, assignment: number)",
    returns = "()",
  },
  removeZone = {
    type = "function",
    description = "Function to remove a zone from the specified layer. For example, this.parent specifies the parent layer of the script module as the layer that contains the zone. The zone to be removed is determined by its Zone object or its position. You can use getZone or findZones to determine the Zone object. The position is the number that indexes the zones in the specified layer.",
    args = "(zoneOrPosition: object|number)",
    returns = "()",
  },
  runAsync = {
    type = "function",
    description = "Executes a function in the controller thread. By calling runAsync in the processor thread, you can invoke a function that is executed in the controller thread. The execution of runAsync takes at least one audio block, or longer, depending on the function which was called. The callback which called runAsync is put on hold until the function has completed. Please be aware of this when using runAsync.",
    args = "(func, arg1, arg2, ...)",
    returns = "()",
  },
  samples2ms = {
    type = "function",
    description = "Function to convert a number of samples to the equivalent duration in milliseconds. The sample rate at which the plug-in runs is taken into account.",
    args = "(samples: number)",
    returns = "(number)",
  },
  setName = {
    type = "function",
    description = "Function to change the name of an element in the Program Tree.",
    args = "(name: string)",
    returns = "()",
  },
  setOutputBus = {
    type = "function",
    description = "Function to assign the output of a zone or bus to the specified output bus. The sending zone or bus is determined by its Element object. The receiving output bus is specified by its Bus object. Setting the output bus to nil enables the default signal routing for the zone or bus.\n\nOutput busses that are higher up in the hierarchy of the Program Tree can be assigned freely. If the sending bus and the receiving output bus have the same parent layer, the output bus must come later in the signal flow.",
    args = "(bus: object|nil)",
    returns = "()",
  },
  setParameter = {
    type = "function",
    description = "Function to set the value of a parameter. The parameter can be determined by name or ID. The new value must match the data type of the parameter. The function will have no effect if the parameter does not exist.",
    args = "(nameOrID: string|number, value)",
    returns = "()",
  },
  setParameterNormalized = {
    type = "function",
    description = "Function to set the value of a parameter in the normalized range from 0 to 1.0. The parameter can be determined by name or ID. This function has no effect if the parameter does not exist or if the value is of the type string.",
    args = "(nameOrID: string|number, value: number)",
    returns = "()",
  },
  setProgram = {
    type = "function",
    description = "Function to set a program in the specified slot of the Program Table or the Slot Rack of the plug-in instance. Before calling this function, you must access the Instance object with this.program.instance. The program is determined by its Program object. To specify the slot in the Program Table, you must use the index argument. To specify the slot in the Slot Rack, you must use a Slot object, for example, via getSlot. The program can be removed from the Slot Rack by using nil as argument.",
    args = "(programOrNil: object|nil [, index of slot: number])",
    returns = "()",
  },
  setQCAssignmentBypass = {
    type = "function",
    description = "Function to set the bypass state of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The  bypass argument sets the bypass state of the quick control assignment.",
    args = "(qc: number, assignment: number, bypass: boolean)",
    returns = "()",
  },
  setQCAssignmentCurve = {
    type = "function",
    description = "Function to set the curve value of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The  curve argument sets the curve value of the quick control assignment in the range -100 % to +100 %.",
    args = "(qc: number, assignment: number, curve: number)",
    returns = "()",
  },
  setQCAssignmentMax = {
    type = "function",
    description = "Function to set the maximum value of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The  max argument sets the maximum value of the quick control assignment. The value range of the maximum value is always 0 to 100 %, even if the type of the quick control assignment is set to Relative or Switch Relative.",
    args = "(qc: number, assignment: number, max: number)",
    returns = "()",
  },
  setQCAssignmentMin = {
    type = "function",
    description = "Function to set the minimum value of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The  min argument sets the minimum value of the quick control assignment. The value range of the minimum value is always 0 to 100 %, even if the type of the quick control assignment is set to Relative or Switch Relative.",
    args = "(qc: number, assignment: number, min: number)",
    returns = "()",
  },
  setQCAssignmentMode = {
    type = "function",
    description = "Function to set the mode of the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The  mode argument sets the mode of the quick control assignment. It can be determined via names or indices.",
    args = "(qc: number, assignment: number, mode: enum|number)",
    returns = "()",
  },
  setQCAssignmentParamId = {
    type = "function",
    description = "Function to set the parameter ID for connecting the corresponding parameter to the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The paramID argument selects the parameter to be connected with the quick control assignment.",
    args = "(qc: number, assignment: number, paramID: number)",
    returns = "()",
  },
  setQCAssignmentScope = {
    type = "function",
    description = "Function to set the scope for the specified quick control assignment. The quick control assignment is determined by the Layer object, the index of the quick control and the index of the assignment itself. For example, this.parent defines the parent layer of the script module as the layer that contains the quick control. The qc argument is the index of the quick control and the assignment argument is the index of the assignment. The indices of the quick controls and the assignments both start counting from 1. The scope is defined by the Element object that you assign to the scope argument.",
    args = "(qc: number, assignment: number, scope: element object)",
    returns = "()",
  },
  setScriptExecTimeOut = {
    type = "function",
    description = "Function to specify the maximum allowed execution time of a function call in the script. If the execution of a function call exceeds the execution time-out, the script will end with an execution error. This prevents the infinite execution of scripts, e.g., in case of an infinite loop. The script execution time-out can be defined separately for the controller and the processor thread. Which execution time-out is set, depends on where setScriptExecTimeOut is called. The duration for the script execution time-out is specified in milliseconds. The default is 5000 ms for the controller thread and 1000 ms for the processor thread.",
    args = "(duration: number)",
    returns = "()",
  },
  setSource1 = {
    type = "function",
    description = "Function to set the 1st modulation source of a row in the modulation matrix. The row is specified with the Zone object of the zone and the index of the modulation matrix row. \nModulation source can be determined via names or indices. See Modulation Source Types for details. Standard modulation sources like the LFOs or the envelopes can be set directly. Special modulation sources like MIDI controllers or MIDI modules can only be set by also specifiying sourceInfo1 and sourceInfo2.",
    args = "(source: enum|number [, sourceInfo1: number|midimodule object [, sourceInfo2: number]])",
    returns = "()",
  },
  setSource2 = {
    type = "function",
    description = "Function to set the 2nd modulation source of a row in the modulation matrix. The row is specified with the Zone object of the zone and the index of the modulation matrix row. \nModulation source can be determined via names or indices. See Modulation Source Types for details. Standard modulation sources like the LFOs or the envelopes can be set directly. Special modulation sources like MIDI controllers or MIDI modules can only be set by also specifiying sourceInfo1 and sourceInfo2.",
    args = "(source: enum|number [, sourceInfo1: number|midimodule object [, sourceInfo2: number]])",
    returns = "()",
  },
  sortEvents = {
    type = "function",
    description = "Function to sort the events of the specified events table according to their PPQ position. The function sorts the events from first to last PPQ position. The events table is part of a tracks table which is part of the MIDI sequence table.",
    args = "(eventTable: table)",
    returns = "()",
  },
  spawn = {
    type = "function",
    description = "Calls a Lua function and executes it in a separate, parallel thread.",
    args = "(func [, arg1 [, arg2 [, ...]]])",
    returns = "()",
  },
  startUndoBlock = {
    type = "function",
    description = "Function to combine multiple undo entries into one undo block. For example, if your script inserts several elements into the program, you might want to be able to remove all the elements in one single undo operation. This function must be terminated using endUndoBlock. Argument is the name for the combined undo entry in the history.",
    args = "(name: string)",
    returns = "()",
  },
  wait = {
    type = "function",
    description = "Function to suspend the execution of a callback for a specific time in milliseconds.",
    args = "(ms: number)",
    returns = "()",
  },
  waitBeat = {
    type = "function",
    description = "Function to suspend the execution of a callback for a specific time. This time is specified in number of beats. One beat equals the length of a quarter note based on the current tempo.",
    args = "(beats: number)",
    returns = "()",
  },
  waitForRelease = {
    type = "function",
    description = "Function to suspend the execution of the onNote callback until the note that called onNote gets released either by a corresponding note-off or sustain pedal off.",
    args = "()",
    returns = "()",
  },
  writeMidiFile = {
    type = "function",
    description = "Function to write a MIDI file (.mid) to disk. Returns true if the MIDI file was written successfully and false if not.",
    args = "(path: string, mididSequence: table)",
    returns = "(boolean)",
  },
}
